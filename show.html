<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SVG Update Demo</title>
	<style>
		body {
			width: 600px;
			max-width: 85%;
			margin-left: auto;
			margin-right: auto;
		}
		svg.showBox {
			border:  1px solid black;
		}
	</style>
</head>
<body>
	<h1>SVG Update Demo</h1>
	<svg viewBox="-5 -5 90 70" class="showBox">
		<!-- The viewBox should contain the 'ground' and 'object' defined below. -->
		<!-- We assume the 'ground' start at (0,0), 80 in width and 60 in height. -->
		<!-- Thus the viewbox is "-5 -5 80+5*2 60+5*2", leaving us a margin of 5. -->
		<defs> <!-- Some predefine -->
			<!-- Using pattern for showing grid. -->
			<pattern id="smallGrid" width="2" height="2" patternUnits="userSpaceOnUse">
				<path d="M 10 0 L 0 0 0 10"/>
			</pattern>
			<pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse">
				<rect width="100" height="100" fill="url(#smallGrid)"/>
				<path d="M 100 0 L 0 0 0 100"/>
			</pattern>
			<!-- Styling the grid and the ground. -->
			<style>
				#smallGrid path {
					stroke: lightseagreen;
					stroke-width: 0.2;
					fill: none;
				}
				#grid path {
					stroke: lightseagreen;
					stroke-width: 0.5;
					fill: none;
				}
				rect#ground {
					stroke: lightseagreen;
					stroke-width: 0.5;
					fill: url(#grid);
				}
			</style>
		</defs>
		<!-- The 'rect' descibe the imaginary ground. -->
		<rect id="ground" x="0" y="0" width="80" height="60" />
		<g id="object"> <!-- We later use 'transform' attribute to update position of this object. -->
			<!-- The 'path' describe the shape of the object, which is an arrow. --> 
			<!-- When defining the path, we assume its center is at (0, 0). Altogether the shape is of a 6x6 size.--> 
			<path d="M 0,1 3,3 0,-3 -3,3 z" fill="black"/>
			<!-- The circle describe the center. which is at (0, 0). --> 
			<circle cx="0" cy="0" r="0.5" fill="red" />
		</g>
	</svg>
	<script>
		// Mock function of getting current position.
		// Return in a colon-seperated format, e.g. '15;34;90' ({x};{y};{deg}).
		function getPos() {
			const d = new Date();
			const T = 15 * 1000;
			const t = (d.getTime() % T) / T;
			const r = 20;
			const x = 40 + Math.sin(2 * Math.PI * t) * r;
			const y = 30 - Math.cos(2 * Math.PI * t) * r;
			return `${x};${y};${90 + t * 360}`
		}
		
		// getting arrow element
		const arrow = document.getElementById('object');

		// 'setInterval' is used for repetitive queries;
		// (here we use a lambda instead of a named function for the hook function)
		setInterval(() => {

			// getting position
			const s = getPos();

			// parsing translate amount of x, y and deg rotated;
			// since we started from (0, 0), x and y translate is same as absolute ones.
			let l = s.split(';');
			const x = Number(l[0]);
			const y = Number(l[1]);
			const d = Number(l[2]);

			// modifing arrtibute for the 'arrow':
			// first translate the object, then rotate (0 ~ 360 degree)
			arrow.setAttribute('transform', `translate(${x} ${y}) rotate(${d})`);
		}, 30); // interval is set to 30 ms (which is about 30 fps).
	</script>
</body>
</html>
